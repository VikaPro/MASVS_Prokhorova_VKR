#include "usertesting.h"

UserTesting::UserTesting(SelectProject * p_select, QObject *parent)
    : viewer(parent)
{
    //reports_model = new ReportsModel();         // модель для отчёта по проекту
    select = p_select;
    // если отчёт успешно сформирован, то говорим qml о завершении всех тестов
    QObject::connect(select, SIGNAL(readReport()), this, SIGNAL(allTestEnd()));
}

void UserTesting::userTest(){
    qDebug() << "Передали уровень в ручные проверки" << levelProject;

    // обнуляем значения глобальных переменных для дальнейшего заполнения
    numbers.clear();
    descriptions.clear();

    QStringList numbersL1 = {"1.1", "1.2", "1.3", "1.4", "1.12", "2.1", "2.4", "3.3", "3.5", "4.2", "4.3", "4.4",
                             "4.6", "4.8", "4.12", "5.2", "6.2", "6.4", "6.7", "6.8", "7.7", "7.8"};
    QStringList descriptionsL1 = {"Все компоненты приложения идентифицированы и используются",
                                  "Проверки безопасности реализованы не только на клиенте, но и на бэкенде",
                                  "Архитектура мобильного приложения учитывает все удалённые сервисы. Безопасность заложена в архитектуре",
                                  "Определены данные, которые являются чувствительными в контексте мобильного приложения",
                                  "Приложение должно соответствовать законам о защите персональных данных",
                                  "Хранилище учетных данных системы должно использоваться надлежащим образом для хранения чувствительных данных, таких как персональные данные, данные пользователя для авторизации и криптографические ключи",
                                  "Никакие чувствительные данные не передаются третьей стороне, если это не является необходимой частью архитектуры",
                                  "Приложение использует подходящие криптографические алгоритмы для каждого конкретного случая, с параметрами, которые соответствуют лучшим практикам индустрии",
                                  "Приложение не использует один и тот же ключ несколько раз",
                                  "Если используются сессии, бекэнд случайно генерирует идентификаторы сессии для аутентификации клиентских запросов без отправки данных учётной записи",
                                  "Если используется аутентификация на основе токена, сервер предоставляет токен, подписанный с использованием безопасного криптоалгоритма",
                                  "Бэкенд удаляет существующую сессию, когда пользователь выходит из системы",
                                  "На сервере реализован механизм защиты от перебора авторизационных данных",
                                  "Сессии становятся невалидными на бэкенде после определенного периода бездействия, срок действия токена истекает",
                                  "Модели авторизации должны быть определены и проверены на сервере",
                                  "Настройки TLS соответствуют современным лучшим практикам, или максимально приближены к ним, если операционная система не поддерживает рекомендуемые стандарты",
                                  "Все данные, поступающие из внешних источников и от пользователя, валидируются и санитизируются. Сюда входят данные, полученные через пользовательский интерфейс, механизмы IPC (такие как intent-ы, кастомные URL-схемы) и из сети",
                                  "Приложение не экспортирует чувствительные данные через IPC механизмы без должной защиты",
                                  "Если нативные методы приложения используются WebView, то необходимо верифицировать, что исполняются только Javascript объекты данного приложения",
                                  "Десериализация объектов, если она есть, реализована с использованием безопасного API",
                                  "В логике обработки ошибок, связанных с безопасностью, по умолчанию доступ запрещается",
                                  "В неконтролируемом коде память выделяется, освобождается и используется безопасно"};

    QStringList numbersL2 = {"1.5", "1.6", "1.7", "1.8", "1.10", "1.11", "2.10", "2.12", "2.13", "2.14", "2.15",
                             "4.7", "4.9", "4.10", "4.11", "5.4", "5.5", "6.10", "6.11"};
    QStringList descriptionsL2 = {"Все компоненты приложения определены с точки зрения бизнес логики и/или безопасности",
                                  "Сформирована модель угроз для мобильного приложения и связанных с ним удаленных сервисов, которая идентифицирует потенциальные угрозы и необходимые контрмеры",
                                  "Все проверки безопасности имеют централизованную реализацию",
                                  "Существует явная политика управления криптографическими ключами (если они есть) и их жизненным циклом. В идеале политика соответствует стандарту управления ключами, например, NIST SP 800-57",
                                  "Безопасность заложена во все этапы жизненного цикла разработки программного обеспечения",
                                  "Существует и эффективно применяется ответственная политика раскрытия информации",
                                  "Приложение не хранит чувствительные данные в памяти дольше, чем необходимо, и полностью удаляет их из памяти после работы с ними",
                                  "Приложение информирует пользователя о персональных данных, которые оно обрабатывает, а также о лучших практиках безопасности, которым должен следовать пользователь при использовании приложения",
                                  "Конфиденциальные данные локально не должны храниться на мобильном устройстве. Вместо этого необходимые данные должны получаться с сервера и храниться только в памяти",
                                  "Если конфиденциальные данные все же требуется хранить локально, они должны быть зашифрованы с помощью ключа, полученного из аппаратного хранилища, которое требует проверки подлинности",
                                  "Локальное хранилище приложения должно быть стерто после превышения допустимого количества неудачных попыток",
                                  "Биометрическая аутентификация не является event-bound (т.е. использует только API, которое возвращает «true» или «false»). Вместо этого она основана на разблокировке keychain/keystore",
                                  "Реализована и поддерживается двухфакторная аутентификация",
                                  "Для выполнения чувствительных транзакций требуется дополнительная или повторная аутентификация",
                                  "Приложение информирует пользователя о всех важных действиях с его учетной записью. Пользователи могут просматривать список устройств, контекстную информацию (IP-адрес, местоположение и т.д.), и блокировать конкретные устройства",
                                  "В приложении реализован SSL pinning и соединение с серверами, которые предлагают другой сертификат или ключ, даже если они подписаны доверенным центром сертификации (CA) не устанавливается",
                                  "Приложение не полагается на единственный небезопасный канал связи (e-mail или SMS) для таких критических операций, как регистрация и восстановление аккаунта",
                                  "Кэш веб-представления, хранилище и загруженные ресурсы (JavaScript и т. д.) должны быть очищены до того, как веб-представление будет уничтожено",
                                  "Убедитесь, что приложение предотвращает использование пользовательских клавиатур сторонних производителей при вводе конфиденциальных данных (только для iOS)"};

    QStringList numbersR = {"8.1", "8.2", "8.3", "8.4", "8.5", "8.6", "8.7", "8.8", "8.9", "8.10", "8.11", "8.12", "8.13"};
    QStringList descriptionsR = {"Приложение обнаруживает и реагирует на наличие root или jailbreak, уведомляя пользователя, либо прекращая работу",
                                 "Приложение не позволяет использовать отладчики и/или обнаруживает и реагирует на использование отладчика. Все доступные протоколы отладки должны быть учтены",
                                 "Приложение обнаруживает и реагирует на внесения изменений в исполняемые файлы и критичные данные в своей песочнице",
                                 "Приложение обнаруживает и реагирует на наличие на устройстве широко используемых инструментов и фреймворков для реверс инжиниринга",
                                 "Приложение обнаруживает и реагирует на запуск на эмуляторе",
                                 "Приложение обнаруживает и реагирует на изменение своего кода и данных в оперативной памяти",
                                 "Приложение реализует несколько механизмов для каждой категории защиты (с 8.1 по 8.6). Обратите внимание, что на устойчивость к атакам влияет количество, разнообразие и оригинальность используемых механизмов",
                                 "Механизмы обнаружения инициируют ответные меры разных типов, включая отложенные и скрытые",
                                 "Обфускация применена в том числе и к тем программным механизмам, которые препятствуют деобфускации методами динамического анализа",
                                 "Приложение реализует функциональность привязки экземпляра приложения к устройству, формируя его отпечаток из нескольких свойств, уникальных для устройства",
                                 "Все исполняемые файлы и библиотеки, принадлежащие приложению, зашифрованы на файловом уровне, либо важные участки кода и данных зашифрованы внутри исполняемых файлов. Простой статический анализ не позволяет обнаружить важный код или данные",
                                 "Если задачей обфускации является защита конфиденциальных данных, то используется схема обфускации, которая подходит не только для этой задачи, но и защищает от ручного тестирования и автоматизированных деобфускаторов и учитывает последние исследования по данной теме",
                                 "В качестве глубокой защиты, наряду с существенным усилением защиты взаимодействия, шифрование обмениваемых приложением сообщений может шифроваться для дальнейшего предотвращения перехвата"};

    if (levelProject == "L1"){
        // для уровня 1 не нужно объединения с другими уровнями
        numbers = numbersL1;
        descriptions = descriptionsL1;

        // посылаем сигнал в qml о количестве ручных проверок
        emit colUserTest(numbers.size());

        // показываем первую карточку для уровня L1
        oneCard(0);         // Требование 1.1
    }

    else if (levelProject == "L2"){
        // для уровня 2 нужно объединить требования 1 и 2 уровней
        numbers += numbersL1 += numbersL2;
        descriptions += descriptionsL1 += descriptionsL2;

        // посылаем сигнал в qml о количестве ручных проверок
        emit colUserTest(numbers.size());

        // показываем первую карточку для уровня L1
        oneCard(0);         // Требование 1.1
    }

    else if (levelProject == "L1 + R"){
        // для уровня L1 + R нужно объединить требования 1 и R уровней
        numbers += numbersL1 += numbersR;
        descriptions += descriptionsL1 += descriptionsR;

        // посылаем сигнал в qml о количестве ручных проверок
        emit colUserTest(numbers.size());

        // показываем первую карточку для уровня L1
        oneCard(0);         // Требование 1.1
    }

    else if (levelProject == "L2 + R"){
        // для уровня L2 + R нужно объединить требования 1, 2 и R уровней
        numbers += numbersL1 += numbersL2 += numbersR;
        descriptions += descriptionsL1 += descriptionsL2 += descriptionsR;

        // посылаем сигнал в qml о количестве ручных проверок
        emit colUserTest(numbers.size());

        // показываем первую карточку для уровня L1
        oneCard(0);         // Требование 1.1
    }

    else{
        qDebug() << "Что-то пошло не так...";
    }

    qDebug() << "Я проверяю вот столько требований: " << numbers.size();
    qDebug() << "И какие именно: " << numbers;

}

void UserTesting::oneCard(int index){
    QString number = numbers[index];
    QString description = descriptions[index];

    // посылаем сигнал в QML для отображения карточки с требованием
    emit showUserCard(number, description, index);
}

void UserTesting::resultUser(QString number, QString description, QString result, int index){
    qDebug() << "Требование: " << number;
    qDebug() << "Описание: " << description;
    qDebug() << "Результат: " << result;
    qDebug() << "Индекс: " << index;
    QString function = "Пользователь";

    //Записываем данные в файл отчёта
    QFile file("C:/MASVS/" + nameProject + "/" + nameProject + ".report");
    file.open(QIODevice::WriteOnly | QIODevice::Text
              | QIODevice::Append );

    QTextStream str_file(&file);
    str_file.setCodec("UTF-8");

    // записываем результат пользовательской проверки в новую строку
    str_file << "***NUMBER: " << number << " ***DESCRIPTION: " << description << " ***RESULT: " << result << " ***FUNCTION: " << function << endl;

    file.close();

    // Если требование не последнее, то вызываем функцию для отображения следующего требования
    if (index < (numbers.size() - 1)){
        oneCard(index+1);
    }

    // Если требование было последним, то запускаем функцию для формирования отчёта
    else{
        select->checkPercent(nameProject); // функция из класса selectproject
        select->showReport(nameProject); // функция из класса selectproject
        // Далее ждём сигнал, см. connect выше
    }
}

void UserTesting::incompleteChecks(int index){
    //Записываем данные в файл отчёта
    QFile file("C:/MASVS/" + nameProject + "/" + nameProject + ".report");
    file.open(QIODevice::WriteOnly | QIODevice::Text
              | QIODevice::Append );

    QTextStream str_file(&file);
    str_file.setCodec("UTF-8");

    QString number;
    QString description;
    QString result = "НЕИЗВЕСТНО";
    QString function = "Пользователь";

    // Удалить
    qDebug() << "Последний INDEX" << index;

    // Завершим запись в файл самостоятельно, отметив все оставшиеся проверки Неизвестными
    for(int i = index; i < numbers.size(); i++){
        number = numbers[i];
        description = descriptions[i];
        // записываем результат пользовательской проверки в новую строку, но со статусом "НЕИЗВЕСТНО"
        str_file << "***NUMBER: " << number << " ***DESCRIPTION: " << description << " ***RESULT: " << result << " ***FUNCTION: " << function << endl;
    }

    file.close();

    qDebug() << "Все проверки записаны";

    // Если требование было последним, то запускаем функцию для формирования отчёта
    select->checkPercent(nameProject); // функция из класса selectproject
    select->showReport(nameProject); // функция из класса selectproject
    qDebug() << "Имя отображаемого отчёта по проекту" << nameProject;

    // Далее ждём сигнал, см. connect выше

}

